// === TSP v2.0 - M√ìDULO MLC (LECTURA CR√çTICA) - FASE 2 MEJORADA ===
// Archivo: js/mlc-module.js
// MEJORAS: 1) Correcci√≥n simple en el formulario, 2) Info de lectura desde vocabulario

console.log('üìö Inicializando M√≥dulo de Lectura Cr√≠tica TSP v2.0 - FASE 2 MEJORADA...');

// === CONFIGURACI√ìN SUPABASE ===
const SUPABASE_CONFIG = {
    url: 'https://kryqjsncqsopjuwymhqd.supabase.co',
    anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtyeXFqc25jcXNvcGp1d3ltaHFkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzMjM3MDEsImV4cCI6MjA2ODg5OTcwMX0.w5HiaFiqlFJ_3QbcprUrufsOXTDWFg1zUMl2J7kWD6Y'
};

// Inicializar Supabase si est√° disponible
let supabase = null;
if (typeof window !== 'undefined' && window.supabase) {
    supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
    console.log('‚úÖ Cliente Supabase inicializado');
} else {
    console.warn('‚ö†Ô∏è Librer√≠a Supabase no encontrada, usando modo desarrollo');
}

// === CLASE PRINCIPAL DEL M√ìDULO MLC ===
class MlcModule {
    constructor() {
        this.currentUser = null;
        this.currentLecture = null;
        this.currentStep = 1;
        this.startTime = null;
        this.endTime = null;
        this.timer = null;
        
        // Estados de pasos con sistema de guardas
        this.stepStates = {
            vocabulary: 'pending',      // pending, active, completed
            testVocabulary: 'locked',   // locked, pending, active, completed
            reading: 'locked',          // locked, pending, active, completed
            comprehension: 'locked'     // locked, pending, active, completed
        };
        
        // Variables para vocabulario y test
        this.vocabularyData = null;
        this.vocabularyTestData = null;
        this.vocabularyAnswers = {};
        this.shuffleSeed = null;
        
        console.log('üéØ M√≥dulo MLC inicializado - FASE 2 MEJORADA');
    }

    // === INICIALIZACI√ìN ===
    async init() {
        try {
            console.log('üöÄ Iniciando m√≥dulo MLC FASE 2 MEJORADA...');
            
            // Cargar usuario de la sesi√≥n
            this.currentUser = this.getUserFromSession();
            
            if (!this.currentUser) {
                console.warn('‚ö†Ô∏è No hay usuario en sesi√≥n');
                this.redirectToDashboard();
                return;
            }

            // Actualizar informaci√≥n del usuario en la interfaz
            this.updateUserInfo();
            
            // Cargar datos de la lectura asignada DESDE SUPABASE
            await this.loadAssignedLectureFromSupabase();
            
            // ‚úÖ MEJORA 2: Mostrar informaci√≥n de la lectura desde el vocabulario
            this.displayLectureInfo();
            
            // Generar seed para aleatorizaci√≥n consistente
            this.generateShuffleSeed();
            
            // Cargar vocabulario (FASE 2) - AHORA DESDE SUPABASE
            await this.loadVocabulary();
            
            // Inicializar el primer paso
            this.goToStep(1);
            
            // Inicializar timer
            this.initTimer();
            
            console.log('‚úÖ M√≥dulo MLC FASE 2 MEJORADA inicializado correctamente');
        } catch (error) {
            console.error('‚ùå Error inicializando m√≥dulo MLC:', error);
            this.showError('Error al cargar el m√≥dulo de lectura cr√≠tica');
        }
    }

    // === GESTI√ìN DE USUARIO ===
    getUserFromSession() {
        // Intentar obtener datos del usuario desde sessionStorage
        const userData = sessionStorage.getItem('tsp_user');
        if (userData) {
            try {
                return JSON.parse(userData);
            } catch (e) {
                console.error('Error parsing user data:', e);
            }
        }
        
        // Datos de prueba para desarrollo
        console.log('üß™ Usando datos de prueba para desarrollo');
        return {
            id: 'user123',
            codigo_estudiante: 'E001002',
            nombres: 'Juan Carlos',
            apellidos: 'P√©rez Gonz√°lez',
            grado: 5
        };
    }

    updateUserInfo() {
        const studentNameEl = document.getElementById('studentName');
        if (studentNameEl && this.currentUser) {
            studentNameEl.textContent = `${this.currentUser.nombres} ${this.currentUser.apellidos}`;
        }
    }

    // ‚úÖ MEJORA 2: MOSTRAR INFORMACI√ìN DE LA LECTURA DESDE EL VOCABULARIO
    displayLectureInfo() {
        console.log('üìã Mostrando informaci√≥n de la lectura...');
        
        if (!this.currentLecture) {
            console.warn('‚ö†Ô∏è No hay lectura cargada para mostrar informaci√≥n');
            return;
        }

        // Buscar el contenedor de informaci√≥n de la lectura (lo agregaremos al HTML)
        let lectureInfoContainer = document.getElementById('lectureInfo');
        
        if (!lectureInfoContainer) {
            // Crear el contenedor si no existe y agregarlo al inicio del vocabulario
            const vocabularySection = document.getElementById('vocabularySection');
            const stepHeader = vocabularySection.querySelector('.step-header');
            
            lectureInfoContainer = document.createElement('div');
            lectureInfoContainer.id = 'lectureInfo';
            lectureInfoContainer.className = 'lecture-info-card';
            
            // Insertar despu√©s del step-header
            stepHeader.parentNode.insertBefore(lectureInfoContainer, stepHeader.nextSibling);
        }

        // ‚úÖ CREAR HTML CON INFORMACI√ìN COMPLETA DE LA LECTURA
        lectureInfoContainer.innerHTML = `
            <div class="lecture-info-content">
                <div class="lecture-info-header">
                    <span class="lecture-icon">üìñ</span>
                    <h3>Informaci√≥n de la Lectura</h3>
                </div>
                <div class="lecture-info-grid">
                    <div class="info-item">
                        <span class="info-label">T√≠tulo:</span>
                        <span class="info-value">${this.currentLecture.titulo || 'No disponible'}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Autor:</span>
                        <span class="info-value">${this.currentLecture.autor || 'No disponible'}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Grado:</span>
                        <span class="info-value">${this.formatGradeRange()}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Palabras:</span>
                        <span class="info-value">${this.currentLecture.palabras || 0} palabras</span>
                    </div>
                </div>
            </div>
        `;

        console.log('‚úÖ Informaci√≥n de la lectura mostrada exitosamente');
    }

    formatGradeRange() {
        if (!this.currentLecture.grado_minimo && !this.currentLecture.grado_maximo) {
            return 'No especificado';
        }
        
        if (this.currentLecture.grado_minimo === this.currentLecture.grado_maximo) {
            return `${this.currentLecture.grado_minimo}¬∞`;
        }
        
        return `${this.currentLecture.grado_minimo}¬∞ - ${this.currentLecture.grado_maximo}¬∞`;
    }

    // === SEED PARA ALEATORIZACI√ìN CONSISTENTE ===
    generateShuffleSeed() {
        // Seed basado en estudiante_id + fecha del d√≠a para reproducibilidad pero no copia entre estudiantes
        const today = new Date().toDateString();
        const seedString = `${this.currentUser.id}_${today}`;
        this.shuffleSeed = this.simpleHash(seedString);
        console.log('üé≤ Seed de aleatorizaci√≥n generado:', this.shuffleSeed);
    }

    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash);
    }

    // === CARGA DE DATOS DESDE SUPABASE ===
    async loadAssignedLectureFromSupabase() {
        console.log('üìñ Cargando lectura asignada DESDE SUPABASE - ALGORITMO MEJORADO...');
        
        try {
            if (!supabase) {
                throw new Error('Cliente Supabase no disponible');
            }

            // PASO 1: Intentar cargar lectura espec√≠fica desde asignaciones
            console.log('üéØ PASO 1: Buscando asignaci√≥n espec√≠fica...');
            const { data: assignmentData, error: assignmentError } = await supabase
                .from('asignaciones_ciclos')
                .select(`
                    *,
                    ciclos (
                        lectura_id,
                        lecturas (
                            id, titulo, autor, palabras, pdf_path,
                            grado_minimo, grado_maximo, vocabulario, preguntas_tc, activo
                        )
                    )
                `)
                .eq('estudiante_id', this.currentUser.id)
                .eq('activo', true)
                .order('created_at', { ascending: false })
                .limit(1);

            if (!assignmentError && assignmentData && assignmentData.length > 0 && assignmentData[0].ciclos?.lecturas) {
                this.currentLecture = assignmentData[0].ciclos.lecturas;
                console.log('‚úÖ PASO 1 EXITOSO: Lectura espec√≠fica asignada:', this.currentLecture.titulo);
                await this.validateLectureData();
                return;
            }

            // PASO 2: Obtener grado real del estudiante desde la BD
            console.log('üìä PASO 2: Obteniendo grado real del estudiante...');
            const studentGrade = await this.getStudentGradeFromDatabase();
            console.log(`üë®‚Äçüéì Grado del estudiante: ${studentGrade || 'NO DEFINIDO'}`);

            if (studentGrade) {
                // PASO 2A: Buscar lecturas apropiadas para el grado
                console.log(`üîç PASO 2A: Buscando lecturas para grado ${studentGrade}...`);
                
                const { data: gradeAppropriate, error: gradeError } = await supabase
                    .from('lecturas')
                    .select('*')
                    .eq('activo', true)
                    .lte('grado_minimo', studentGrade)  // grado_minimo <= 5
                    .gte('grado_maximo', studentGrade)  // grado_maximo >= 5
                    .order('grado_minimo', { ascending: true })
                    .order('created_at', { ascending: false });

                if (!gradeError && gradeAppropriate && gradeAppropriate.length > 0) {
                    const bestLecture = this.selectBestLectureForGrade(gradeAppropriate, studentGrade);
                    this.currentLecture = bestLecture;
                    console.log(`‚úÖ PASO 2A EXITOSO: Lectura para grado ${studentGrade}:`, this.currentLecture.titulo);
                    await this.validateLectureData();
                    return;
                }
            }

            // PASO 3: Buscar lecturas generales (sin filtro de grado)
            console.log('üîç PASO 3: Buscando lecturas generales...');
            const { data: generalLectures, error: generalError } = await supabase
                .from('lecturas')
                .select('*')
                .eq('activo', true)
                .order('grado_minimo', { ascending: true })
                .order('created_at', { ascending: false })
                .limit(10);

            if (!generalError && generalLectures && generalLectures.length > 0) {
                const defaultLecture = this.selectDefaultLecture(generalLectures, studentGrade);
                this.currentLecture = defaultLecture;
                console.log('‚úÖ PASO 3 EXITOSO: Lectura por defecto:', this.currentLecture.titulo);
                await this.validateLectureData();
                return;
            }

            // Si llegamos aqu√≠, no hay lecturas disponibles
            throw new Error('No hay lecturas disponibles en la base de datos');
            
        } catch (error) {
            console.error('‚ùå Error cargando lectura desde Supabase:', error);
            throw new Error(`Error al cargar lectura: ${error.message}`);
        }
    }

    // === FUNCI√ìN PARA OBTENER GRADO REAL DEL ESTUDIANTE ===
    async getStudentGradeFromDatabase() {
        try {
            console.log('üîç Consultando grado del estudiante en BD...');
            
            const { data: userData, error: userError } = await supabase
                .from('usuarios')
                .select(`
                    *,
                    grupos (grado, nombre)
                `)
                .eq('id', this.currentUser.id)
                .single();

            if (!userError && userData) {
                if (userData.grupos && userData.grupos.grado) {
                    console.log(`üìä Grado desde grupos: ${userData.grupos.grado}`);
                    return userData.grupos.grado;
                }
                
                if (userData.grado) {
                    console.log(`üìä Grado directo en usuario: ${userData.grado}`);
                    return userData.grado;
                }
            }

            console.warn('‚ö†Ô∏è No se encontr√≥ grado en la BD, usando fallback');
            return this.currentUser.grado || null;
            
        } catch (error) {
            console.error('‚ùå Error obteniendo grado:', error);
            return this.currentUser.grado || null;
        }
    }

    // === FUNCI√ìN PARA SELECCIONAR LA MEJOR LECTURA PARA EL GRADO ===
    selectBestLectureForGrade(lectures, studentGrade) {
        console.log(`üéØ Seleccionando mejor lectura de ${lectures.length} opciones para grado ${studentGrade}`);
        
        const exactMatch = lectures.filter(l => l.grado_minimo === studentGrade && l.grado_maximo === studentGrade);
        const goodMatch = lectures.filter(l => l.grado_minimo <= studentGrade && l.grado_maximo >= studentGrade && !(l.grado_minimo === studentGrade && l.grado_maximo === studentGrade));
        const acceptable = lectures.filter(l => l.grado_minimo <= studentGrade || l.grado_maximo >= studentGrade);
        
        console.log(`üìä Opciones encontradas:`);
        console.log(`- Exactas (grado ${studentGrade}): ${exactMatch.length}`);
        console.log(`- Compatibles: ${goodMatch.length}`);
        console.log(`- Aceptables: ${acceptable.length}`);
        
        if (exactMatch.length > 0) {
            console.log('‚úÖ Usando lectura exacta para el grado');
            return exactMatch[0];
        }
        
        if (goodMatch.length > 0) {
            console.log('‚úÖ Usando lectura compatible');
            return goodMatch[0];
        }
        
        if (acceptable.length > 0) {
            console.log('‚ö†Ô∏è Usando lectura aceptable (no ideal)');
            return acceptable[0];
        }
        
        console.log('‚ö†Ô∏è Fallback: primera lectura disponible');
        return lectures[0];
    }

    // === FUNCI√ìN PARA SELECCIONAR LECTURA POR DEFECTO ===
    selectDefaultLecture(lectures, studentGrade) {
        console.log(`üéØ Seleccionando lectura por defecto de ${lectures.length} opciones`);
        
        if (studentGrade) {
            console.log(`üìä Buscando la m√°s cercana al grado ${studentGrade}`);
            
            const withDistance = lectures.map(lecture => {
                const avgGrade = (lecture.grado_minimo + lecture.grado_maximo) / 2;
                const distance = Math.abs(avgGrade - studentGrade);
                return { ...lecture, distance };
            });
            
            withDistance.sort((a, b) => a.distance - b.distance);
            console.log(`‚úÖ Lectura m√°s cercana: "${withDistance[0].titulo}" (distancia: ${withDistance[0].distance})`);
            return withDistance[0];
        }
        
        const basicGrade = lectures.find(l => l.grado_minimo <= 3);
        if (basicGrade) {
            console.log('‚úÖ Usando lectura de grado b√°sico');
            return basicGrade;
        }
        
        console.log('‚ö†Ô∏è Usando primera lectura disponible');
        return lectures[0];
    }

    // === VALIDACI√ìN DE DATOS DE LECTURA ===
    async validateLectureData() {
        console.log('üîç Validando estructura de datos de la lectura...');
        
        if (!this.currentLecture) {
            throw new Error('No hay lectura cargada');
        }

        const requiredFields = ['id', 'titulo', 'autor', 'palabras', 'vocabulario', 'preguntas_tc'];
        for (const field of requiredFields) {
            if (!this.currentLecture[field]) {
                console.warn(`‚ö†Ô∏è Campo faltante o vac√≠o: ${field}`);
            }
        }

        if (!this.currentLecture.vocabulario || !this.currentLecture.vocabulario.items) {
            throw new Error('Estructura de vocabulario inv√°lida. Se esperaba vocabulario.items[]');
        }

        if (!Array.isArray(this.currentLecture.vocabulario.items)) {
            throw new Error('vocabulario.items debe ser un array');
        }

        if (this.currentLecture.vocabulario.items.length === 0) {
            throw new Error('No hay t√©rminos de vocabulario disponibles');
        }

        if (!this.currentLecture.preguntas_tc || !this.currentLecture.preguntas_tc.preguntas) {
            throw new Error('Estructura de preguntas de comprensi√≥n inv√°lida. Se esperaba preguntas_tc.preguntas[]');
        }

        if (!Array.isArray(this.currentLecture.preguntas_tc.preguntas)) {
            throw new Error('preguntas_tc.preguntas debe ser un array');
        }

        if (this.currentLecture.preguntas_tc.preguntas.length === 0) {
            throw new Error('No hay preguntas de comprensi√≥n disponibles');
        }

        console.log('‚úÖ Estructura de datos validada:');
        console.log(`- T√≠tulo: ${this.currentLecture.titulo}`);
        console.log(`- Autor: ${this.currentLecture.autor}`);
        console.log(`- Palabras: ${this.currentLecture.palabras}`);
        console.log(`- T√©rminos de vocabulario: ${this.currentLecture.vocabulario.items.length}`);
        console.log(`- Preguntas de comprensi√≥n: ${this.currentLecture.preguntas_tc.preguntas.length}`);
    }

    // === VOCABULARIO ===
    async loadVocabulary() {
        console.log('üìö Cargando vocabulario DESDE SUPABASE...');
        
        try {
            if (!this.currentLecture || !this.currentLecture.vocabulario || !this.currentLecture.vocabulario.items) {
                throw new Error('No hay vocabulario disponible en la lectura cargada');
            }

            this.vocabularyData = this.currentLecture.vocabulario.items;
            
            console.log('üìä Vocabulario cargado desde Supabase:');
            console.log(`- Total de t√©rminos: ${this.vocabularyData.length}`);
            this.vocabularyData.forEach((item, index) => {
                console.log(`  ${index + 1}. ${item.termino}: ${item.definicion?.substring(0, 50)}...`);
            });
            
            await this.renderVocabulary();
            this.prepareVocabularyTest();
            this.enableContinueToTest();
            
            console.log('‚úÖ Vocabulario cargado desde Supabase - T√©rminos disponibles:', this.vocabularyData.length);
            
        } catch (error) {
            console.error('‚ùå Error cargando vocabulario desde Supabase:', error);
            this.showError(`Error al cargar el vocabulario: ${error.message}`);
        }
    }

    async renderVocabulary() {
        const container = document.getElementById('vocabularyContent');
        
        if (!this.vocabularyData || this.vocabularyData.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: var(--error-600);">No hay vocabulario disponible</p>';
            return;
        }

        const vocabularyHTML = this.vocabularyData.map(item => `
            <div class="vocabulary-item">
                <div class="term-number">${item.indice || (this.vocabularyData.indexOf(item) + 1)}</div>
                <div class="term-content">
                    <h4>${item.termino}</h4>
                    <p class="term-definition">${item.definicion}</p>
                </div>
            </div>
        `).join('');

        container.innerHTML = vocabularyHTML;
        
        console.log('üìö Marcando vocabulario como completado...');
        this.stepStates.vocabulary = 'completed';
        this.stepStates.testVocabulary = 'pending';
        
        console.log('‚úÖ Vocabulario renderizado desde Supabase y marcado como completado');
    }

    enableContinueToTest() {
        const btn = document.getElementById('continueToTestBtn');
        if (btn) {
            btn.disabled = false;
            btn.style.opacity = '1';
            console.log('‚úÖ Bot√≥n "Continuar al Test" habilitado');
        } else {
            console.warn('‚ö†Ô∏è Bot√≥n continueToTestBtn no encontrado');
        }
    }

    // === TEST DE VOCABULARIO ===
    prepareVocabularyTest() {
        console.log('üìù Preparando test de vocabulario con datos de Supabase...');
        
        this.vocabularyTestData = this.vocabularyData.map(item => {
            if (!item.pregunta || !item.opciones || !item.respuesta_correcta) {
                console.warn('‚ö†Ô∏è T√©rmino sin pregunta completa:', item.termino);
                return null;
            }

            const shuffledOptions = this.shuffleOptionsWithSeed(item.opciones, this.shuffleSeed + (item.indice || 0));
            
            return {
                ...item,
                shuffledOptions: shuffledOptions,
                correctAnswerAfterShuffle: this.findCorrectAfterShuffle(item.opciones, item.respuesta_correcta, shuffledOptions)
            };
        }).filter(item => item !== null);
        
        console.log('‚úÖ Test de vocabulario preparado con datos de Supabase:');
        console.log(`- Preguntas v√°lidas: ${this.vocabularyTestData.length}`);
    }

    shuffleOptionsWithSeed(opciones, seed) {
        const letters = ['A', 'B', 'C', 'D'];
        const optionsArray = letters.map(letter => ({
            letter: letter,
            text: opciones[letter]
        })).filter(option => option.text);
        
        for (let i = optionsArray.length - 1; i > 0; i--) {
            const j = Math.floor(this.seededRandom(seed + i) * (i + 1));
            [optionsArray[i], optionsArray[j]] = [optionsArray[j], optionsArray[i]];
        }
        
        const shuffled = {};
        optionsArray.forEach((option, index) => {
            shuffled[letters[index]] = option.text;
        });
        
        return shuffled;
    }

    findCorrectAfterShuffle(originalOptions, originalCorrect, shuffledOptions) {
        const correctText = originalOptions[originalCorrect];
        
        for (const letter of ['A', 'B', 'C', 'D']) {
            if (shuffledOptions[letter] === correctText) {
                return letter;
            }
        }
        
        return 'A';
    }

    seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }

    loadVocabularyTest() {
        console.log('üìù Cargando test de vocabulario con datos de Supabase...');
        
        const container = document.getElementById('vocabularyTestContent');
        
        if (!this.vocabularyTestData || this.vocabularyTestData.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: var(--error-600);">Error cargando el test desde Supabase</p>';
            return;
        }

        const questionsHTML = this.vocabularyTestData.map(item => `
            <div class="question-item" data-question-id="${item.indice || this.vocabularyTestData.indexOf(item) + 1}">
                <div class="question-header">
                    <span class="question-number">Pregunta ${item.indice || this.vocabularyTestData.indexOf(item) + 1}</span>
                </div>
                <div class="question-text">
                    ${item.pregunta}
                </div>
                <div class="question-options">
                    ${Object.entries(item.shuffledOptions).map(([letter, text]) => `
                        <label class="option-label" data-letter="${letter}">
                            <input type="radio" name="question_${item.indice || this.vocabularyTestData.indexOf(item) + 1}" value="${letter}" 
                                   onchange="selectVocabularyAnswer(${item.indice || this.vocabularyTestData.indexOf(item) + 1}, '${letter}')">
                            <span class="option-text">${letter}. ${text}</span>
                        </label>
                    `).join('')}
                </div>
            </div>
        `).join('');

        container.innerHTML = questionsHTML;
        
        console.log('‚úÖ Test de vocabulario cargado con datos de Supabase y opciones aleatorizadas');
    }

    selectVocabularyAnswer(questionId, answer) {
        console.log(`üìù Respuesta seleccionada - Pregunta ${questionId}: ${answer}`);
        
        this.vocabularyAnswers[questionId] = answer;
        
        // Marcar visualmente la pregunta como respondida
        const questionItem = document.querySelector(`[data-question-id="${questionId}"]`);
        if (questionItem) {
            questionItem.classList.add('answered');
        }
        
        // Marcar opci√≥n como seleccionada
        const options = document.querySelectorAll(`input[name="question_${questionId}"]`);
        options.forEach(option => {
            const label = option.closest('.option-label');
            label.classList.toggle('selected', option.checked);
        });
        
        this.checkTestProgress();
    }

    checkTestProgress() {
        const totalQuestions = this.vocabularyTestData.length;
        const answeredQuestions = Object.keys(this.vocabularyAnswers).length;
        
        console.log(`üìä Progreso del test: ${answeredQuestions}/${totalQuestions}`);
        
        const submitBtn = document.getElementById('submitTestBtn');
        if (submitBtn) {
            submitBtn.disabled = answeredQuestions < totalQuestions;
            submitBtn.style.opacity = answeredQuestions < totalQuestions ? '0.6' : '1';
        }
    }

    async submitVocabularyTest() {
        console.log('üìù Enviando test de vocabulario...');
        
        try {
            const results = this.calculateVocabularyResults();
            
            // ‚úÖ MEJORA 1: Mostrar correcci√≥n simple directamente en el formulario
            this.showSimpleCorrection(results);
            
            // Verificar si puede continuar al siguiente paso
            if (results.score === results.total) {
                this.stepStates.testVocabulary = 'completed';
                this.stepStates.reading = 'pending';
                this.enableContinueToReading();
                console.log(`‚úÖ Test aprobado ${results.score}/${results.total} - Lectura desbloqueada`);
            } else {
                console.log(`‚ùå Test no aprobado ${results.score}/${results.total} - Lectura sigue bloqueada`);
                this.showRetryOption();
            }
            
        } catch (error) {
            console.error('‚ùå Error enviando test:', error);
            this.showError('Error al procesar las respuestas');
        }
    }

    calculateVocabularyResults() {
        let correctAnswers = 0;
        const details = [];
        
        this.vocabularyTestData.forEach(item => {
            const questionId = item.indice || this.vocabularyTestData.indexOf(item) + 1;
            const userAnswer = this.vocabularyAnswers[questionId];
            const isCorrect = userAnswer === item.correctAnswerAfterShuffle;
            
            if (isCorrect) correctAnswers++;
            
            details.push({
                question: questionId,
                userAnswer: userAnswer,
                correctAnswer: item.correctAnswerAfterShuffle,
                isCorrect: isCorrect,
                term: item.termino,
                originalData: item
            });
        });
        
        return {
            score: correctAnswers,
            total: this.vocabularyTestData.length,
            percentage: (correctAnswers / this.vocabularyTestData.length) * 100,
            details: details
        };
    }

    // ‚úÖ MEJORA 1: FUNCI√ìN PARA CORRECCI√ìN SIMPLE DIRECTAMENTE EN EL FORMULARIO
    showSimpleCorrection(results) {
        console.log('üé® Aplicando correcci√≥n visual simple en el formulario...');

        // Ocultar bot√≥n de enviar
        const submitBtn = document.getElementById('submitTestBtn');
        if (submitBtn) {
            submitBtn.style.display = 'none';
        }

        // Aplicar colores a cada pregunta
        results.details.forEach(detail => {
            const questionItem = document.querySelector(`[data-question-id="${detail.question}"]`);
            if (!questionItem) return;

            // Obtener todas las opciones de esta pregunta
            const options = questionItem.querySelectorAll('.option-label');
            
            options.forEach(optionLabel => {
                const letter = optionLabel.dataset.letter;
                const radio = optionLabel.querySelector('input[type="radio"]');
                
                // Si es la respuesta que eligi√≥ el usuario
                if (letter === detail.userAnswer) {
                    if (detail.isCorrect) {
                        // ‚úÖ Respuesta correcta -> verde
                        optionLabel.style.backgroundColor = '#d1fae5';
                        optionLabel.style.borderColor = '#10b981';
                        optionLabel.style.color = '#065f46';
                        optionLabel.innerHTML = optionLabel.innerHTML.replace(letter + '.', letter + '. ‚úÖ');
                    } else {
                        // ‚ùå Respuesta incorrecta -> rojo
                        optionLabel.style.backgroundColor = '#fee2e2';
                        optionLabel.style.borderColor = '#ef4444';
                        optionLabel.style.color = '#991b1b';
                        optionLabel.innerHTML = optionLabel.innerHTML.replace(letter + '.', letter + '. ‚ùå');
                    }
                }
                
                // Si es la respuesta correcta (y no la eligi√≥ el usuario)
                if (letter === detail.correctAnswer && letter !== detail.userAnswer) {
                    // ‚úÖ Mostrar la correcta en verde
                    optionLabel.style.backgroundColor = '#d1fae5';
                    optionLabel.style.borderColor = '#10b981';
                    optionLabel.style.color = '#065f46';
                    optionLabel.innerHTML = optionLabel.innerHTML.replace(letter + '.', letter + '. ‚úÖ (Correcta)');
                }
                
                // Deshabilitar todos los radio buttons
                radio.disabled = true;
            });

            // Agregar clase para indicar que est√° corregida
            questionItem.classList.add('corrected');
            questionItem.classList.add(detail.isCorrect ? 'correct' : 'incorrect');
        });

        // Mostrar resumen general al final
        this.showSummaryResults(results);

        console.log('‚úÖ Correcci√≥n visual simple aplicada exitosamente');
    }

    // ‚úÖ FUNCI√ìN PARA MOSTRAR RESUMEN GENERAL
    showSummaryResults(results) {
        const resultsContainer = document.getElementById('testResults');
        
        const isSuccess = results.score === results.total;
        const resultClass = isSuccess ? 'success' : 'error';
        const resultMessage = isSuccess 
            ? '¬°Perfecto! Has completado el vocabulario correctamente.' 
            : `Necesitas ${results.total}/${results.total} para continuar. Obtuviste ${results.score}/${results.total}.`;
        
        resultsContainer.innerHTML = `
            <div class="result-score ${resultClass}">
                ${results.score}/${results.total}
            </div>
            <div class="result-message">
                ${resultMessage}
            </div>
            <div class="result-details">
                ${isSuccess 
                    ? 'Ahora puedes continuar a la lectura del texto.' 
                    : 'Revisa las respuestas marcadas arriba y vuelve a intentarlo.'
                }
            </div>
        `;
        
        resultsContainer.style.display = 'block';
        resultsContainer.className = `test-results ${resultClass}`;
        
        console.log(`‚úÖ Resumen de resultados mostrado: ${results.score}/${results.total}`);
    }

    enableContinueToReading() {
        const btn = document.getElementById('continueToReadingBtn');
        if (btn) {
            btn.style.display = 'inline-flex';
            btn.disabled = false;
        }
    }

    showRetryOption() {
        const actions = document.querySelector('#testVocabularySection .step-actions');
        
        const retryBtn = document.createElement('button');
        retryBtn.className = 'btn btn-warning';
        retryBtn.onclick = () => this.retryVocabularyTest();
        retryBtn.innerHTML = 'üîÑ Intentar de Nuevo';
        
        actions.appendChild(retryBtn);
    }

    retryVocabularyTest() {
        console.log('üîÑ Reintentando test de vocabulario...');
        
        // Limpiar respuestas
        this.vocabularyAnswers = {};
        
        // Generar nuevo seed para diferentes opciones
        this.shuffleSeed = this.shuffleSeed + 1000;
        
        // Preparar nuevo test
        this.prepareVocabularyTest();
        this.loadVocabularyTest();
        
        // Ocultar resultados
        const resultsContainer = document.getElementById('testResults');
        resultsContainer.style.display = 'none';
        
        // Restaurar bot√≥n de enviar
        const submitBtn = document.getElementById('submitTestBtn');
        if (submitBtn) {
            submitBtn.style.display = 'inline-flex';
            submitBtn.disabled = true;
        }
        
        // Ocultar bot√≥n de continuar y quitar retry
        const continueBtn = document.getElementById('continueToReadingBtn');
        if (continueBtn) {
            continueBtn.style.display = 'none';
        }
        
        const retryBtn = document.querySelector('.btn-warning');
        if (retryBtn) {
            retryBtn.remove();
        }
    }

    // === NAVEGACI√ìN ENTRE PASOS CON GUARDAS ===
    goToStep(stepNumber) {
        console.log(`üìç Navegando al paso ${stepNumber}`);
        
        if (stepNumber < 1 || stepNumber > 4) {
            console.error('‚ùå N√∫mero de paso inv√°lido:', stepNumber);
            return;
        }

        if (!this.canAccessStep(stepNumber)) {
            console.warn(`üö´ Acceso denegado al paso ${stepNumber}`);
            this.showAccessDeniedMessage(stepNumber);
            return;
        }

        this.currentStep = stepNumber;
        
        const sections = document.querySelectorAll('.step-section');
        sections.forEach(section => {
            section.classList.remove('active');
        });
        
        const sectionIds = [
            '',
            'vocabularySection',
            'testVocabularySection', 
            'readingSection',
            'comprehensionSection'
        ];
        
        const targetSection = document.getElementById(sectionIds[stepNumber]);
        if (targetSection) {
            targetSection.classList.add('active');
        }
        
        this.updateProgress();
        this.executeStepActions(stepNumber);
    }

    canAccessStep(stepNumber) {
        console.log(`üîç Verificando acceso al paso ${stepNumber}...`);
        this.logCurrentStates();
        
        let canAccess = false;
        
        switch(stepNumber) {
            case 1:
                canAccess = true;
                break;
            case 2:
                canAccess = this.stepStates.vocabulary === 'completed';
                console.log(`üìù Paso 2 - Vocabulario completado? ${canAccess}`);
                break;
            case 3:
                canAccess = this.stepStates.testVocabulary === 'completed';
                console.log(`üìñ Paso 3 - Test completado? ${canAccess}`);
                break;
            case 4:
                canAccess = this.stepStates.reading === 'completed';
                console.log(`üß† Paso 4 - Lectura completada? ${canAccess}`);
                break;
            default:
                canAccess = false;
        }
        
        console.log(`${canAccess ? '‚úÖ' : '‚ùå'} Acceso al paso ${stepNumber}: ${canAccess ? 'PERMITIDO' : 'DENEGADO'}`);
        return canAccess;
    }

    logCurrentStates() {
        console.log('üîç ESTADO ACTUAL DE PASOS:');
        console.log('- Vocabulario:', this.stepStates.vocabulary);
        console.log('- Test Vocabulario:', this.stepStates.testVocabulary);
        console.log('- Lectura:', this.stepStates.reading);
        console.log('- Comprensi√≥n:', this.stepStates.comprehension);
    }

    showAccessDeniedMessage(stepNumber) {
        const stepNames = ['', 'Vocabulario', 'Test de Vocabulario', 'Lectura', 'Comprensi√≥n'];
        alert(`‚ö†Ô∏è Debes completar el paso anterior antes de acceder a "${stepNames[stepNumber]}"`);
    }

    executeStepActions(stepNumber) {
        switch(stepNumber) {
            case 1:
                console.log('üìñ Activando estudio de vocabulario');
                if (this.stepStates.vocabulary !== 'completed') {
                    this.stepStates.vocabulary = 'active';
                }
                break;
            case 2:
                console.log('üìù Activando test de vocabulario');
                if (this.stepStates.testVocabulary !== 'completed') {
                    this.stepStates.testVocabulary = 'active';
                }
                this.loadVocabularyTest();
                break;
            case 3:
                console.log('‚è±Ô∏è Activando lectura con cron√≥metro');
                if (this.stepStates.reading !== 'completed') {
                    this.stepStates.reading = 'active';
                }
                this.startTimer();
                break;
            case 4:
                console.log('üß† Activando test de comprensi√≥n');
                if (this.stepStates.comprehension !== 'completed') {
                    this.stepStates.comprehension = 'active';
                }
                this.stopTimer();
                break;
        }
        
        this.updateStepIndicators();
    }

    // === ACTUALIZACI√ìN DE INTERFAZ ===
    updateProgress() {
        const progressFill = document.getElementById('progressFill');
        if (progressFill) {
            const percentage = (this.currentStep / 4) * 100;
            progressFill.style.width = `${percentage}%`;
        }
    }

    updateStepIndicators() {
        for (let i = 1; i <= 4; i++) {
            const stepEl = document.getElementById(`step${i}Progress`);
            if (stepEl) {
                stepEl.classList.remove('active', 'completed');
                
                if (i < this.currentStep) {
                    stepEl.classList.add('completed');
                } else if (i === this.currentStep) {
                    stepEl.classList.add('active');
                }
            }
        }
    }

    // === CRON√ìMETRO ===
    initTimer() {
        this.startTime = null;
        this.endTime = null;
        this.updateTimerDisplay('00:00:00');
    }

    startTimer() {
        if (!this.startTime) {
            this.startTime = Date.now();
            console.log('‚è±Ô∏è Cron√≥metro iniciado');
            
            this.timer = setInterval(() => {
                this.updateTimerDisplay();
            }, 1000);
        }
    }

    stopTimer() {
        if (this.timer) {
            clearInterval(this.timer);
            this.endTime = Date.now();
            console.log('‚èπÔ∏è Cron√≥metro detenido');
            
            const elapsedMs = this.endTime - this.startTime;
            console.log(`üìä Tiempo de lectura: ${elapsedMs}ms`);
        }
    }

    updateTimerDisplay(timeString = null) {
        const timerEl = document.getElementById('timerDisplay');
        if (timerEl) {
            if (timeString) {
                timerEl.textContent = timeString;
            } else if (this.startTime) {
                const elapsedMs = Date.now() - this.startTime;
                const formatted = this.formatTime(elapsedMs);
                timerEl.textContent = formatted;
            }
        }
    }

    formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // === FINALIZACI√ìN ===
    finishMLC() {
        console.log('üéâ Finalizando m√≥dulo MLC...');
        
        const elapsedMs = this.endTime - this.startTime;
        const words = this.currentLecture ? this.currentLecture.palabras : 0;
        const wpm = words > 0 ? (words * 60000) / elapsedMs : 0;
        
        console.log('üìä M√©tricas calculadas:');
        console.log(`- Tiempo: ${elapsedMs}ms`);
        console.log(`- Palabras: ${words}`);
        console.log(`- WPM: ${wpm.toFixed(1)}`);
        
        alert(`üéâ ¬°M√≥dulo MLC FASE 2 MEJORADA completado!\n\nüìö Vocabulario: ‚úÖ Completado (datos de Supabase)\nüìù Test: ‚úÖ ${this.vocabularyTestData.length}/${this.vocabularyTestData.length}\n‚è±Ô∏è Tiempo de lectura: ${this.formatTime(elapsedMs)}\nüìà Velocidad: ${wpm.toFixed(1)} WPM\nüóÑÔ∏è Lectura: "${this.currentLecture.titulo}"\n\n(FASE 3 y 4 pr√≥ximamente)`);
        
        this.redirectToDashboard();
    }

    // === NAVEGACI√ìN ===
    redirectToDashboard() {
        console.log('üîÑ Redirigiendo al dashboard...');
        window.location.href = 'dashboard-estudiante.html';
    }

    // === UTILIDADES ===
    showError(message) {
        console.error('‚ùå', message);
        alert(`Error: ${message}`);
    }

    showSuccess(message) {
        console.log('‚úÖ', message);
    }

    formatDate(date) {
        return new Date(date).toLocaleDateString('es-CO', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            timeZone: 'America/Bogota'
        });
    }
}

// === FUNCIONES GLOBALES ===
let mlcModule = null;

function goToStep(stepNumber) {
    if (mlcModule) {
        mlcModule.goToStep(stepNumber);
    } else {
        console.error('‚ùå M√≥dulo MLC no inicializado');
    }
}

function selectVocabularyAnswer(questionId, answer) {
    if (mlcModule) {
        mlcModule.selectVocabularyAnswer(questionId, answer);
    } else {
        console.error('‚ùå M√≥dulo MLC no inicializado');
    }
}

function submitVocabularyTest() {
    if (mlcModule) {
        mlcModule.submitVocabularyTest();
    } else {
        console.error('‚ùå M√≥dulo MLC no inicializado');
    }
}

function finishMLC() {
    if (mlcModule) {
        mlcModule.finishMLC();
    } else {
        console.error('‚ùå M√≥dulo MLC no inicializado');
    }
}

// === INICIALIZACI√ìN AUTOM√ÅTICA ===
document.addEventListener('DOMContentLoaded', async function() {
    console.log('üéì DOM cargado, inicializando m√≥dulo MLC FASE 2 MEJORADA...');
    
    try {
        mlcModule = new MlcModule();
        await mlcModule.init();
    } catch (error) {
        console.error('‚ùå Error fatal inicializando m√≥dulo MLC:', error);
        alert('Error al cargar el m√≥dulo. Por favor, intenta nuevamente.');
        
        setTimeout(() => {
            window.location.href = 'dashboard-estudiante.html';
        }, 2000);
    }
});

// === MANEJO DE ERRORES GLOBALES ===
window.addEventListener('error', function(event) {
    console.error('‚ùå Error global capturado:', event.error);
});

console.log('üìö M√≥dulo MLC FASE 2 MEJORADA cargado exitosamente - DATOS DESDE SUPABASE + CORRECCI√ìN SIMPLE + INFO LECTURA');

// === EXPORTAR PARA DEBUGGING ===
if (typeof window !== 'undefined') {
    window.mlcModule = mlcModule;
    window.goToStep = goToStep;
    window.selectVocabularyAnswer = selectVocabularyAnswer;
    window.submitVocabularyTest = submitVocabularyTest;
    window.finishMLC = finishMLC;
}